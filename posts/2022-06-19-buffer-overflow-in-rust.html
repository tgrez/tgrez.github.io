<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Tomasz Guz - Playing with buffer overflow in Rust</title>
        <link rel="stylesheet" href="../css/default.css" />
        <link rel="stylesheet" href="../css/syntax.css" />
    </head>
    <body>
        <header>
            <div class="wrapper">
                <div class="topbar">
                    <div class="logo">
                        <a href="../">Tomasz Guz</a>
                    </div>
                    <nav>
                        <a href="../">Home</a>
                        <a href="https://github.com/tgrez">GitHub</a>
                        <a href="https://www.linkedin.com/in/tomasz-guz-333088109/">LinkedIn</a>
                    </nav>
                </div>
            </div>
        </header>

        <main role="main">
            <div class="wrapper">
                <h1>Playing with buffer overflow in Rust</h1>
                <article>
    <section class="header">
        Posted on June 19, 2022
        
    </section>
    <section>
        <h2 id="foreword">1. Foreword</h2>
<p>For a long time I wanted to play with a buffer overflow exploit. The idea is pretty simple: the “attacker” prepares specially crafted input, so that too many bytes are written into the buffer and, as a result, adjacent memory locations are overwritten, potentially changing the behavior of the program. Initially my idea was to implement this using C, but after I started learning Rust I was also curious how would it differ. In general, it’s just a small exercise in using raw function pointers in Rust.</p>
<p>Of course, performing such attack in the wild is much harder than locally in our own program, where we can change the code, how it is executed, turn off protections and it’s easy to check memory locations used. But still, it’s fun ;)</p>
<h2 id="an-example-in-c">2. An example in C</h2>
<p>To avoid overcomplicating things I looked for a tutorial how to do it in C first. My choice was to use a struct with a buffer and a pointer to a function, which is executed after reading the first command line argument into the buffer. One of the easiest ways to make use of buffer overflow. This is the tutorial, which describes such example: <a href="https://infosecwriteups.com/into-the-art-of-binary-exploitation-0x000001-stack-based-overflow-50fe48d58f10">Into the art of Binary Exploitation 0x00000</a>.</p>
<p>And here is the code in C, taken from this tutorial:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="pp">#include </span><span class="im">&lt;string.h&gt;</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="dt">void</span> abracadabra() {</a>
<a class="sourceLine" id="cb1-6" title="6"> printf(<span class="st">&quot;Abracadabra! Function called!</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-7" title="7"> exit(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-8" title="8">}</a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="dt">int</span> main(<span class="dt">int</span> argc, <span class="dt">char</span> **argv) {</a>
<a class="sourceLine" id="cb1-11" title="11">  <span class="kw">struct</span> {</a>
<a class="sourceLine" id="cb1-12" title="12">    <span class="dt">char</span> buffer[<span class="dv">64</span>];</a>
<a class="sourceLine" id="cb1-13" title="13">    <span class="dt">volatile</span> <span class="dt">int</span> (*point)();</a>
<a class="sourceLine" id="cb1-14" title="14">  } hackvist;</a>
<a class="sourceLine" id="cb1-15" title="15"></a>
<a class="sourceLine" id="cb1-16" title="16">  hackvist.point = NULL;</a>
<a class="sourceLine" id="cb1-17" title="17">  strcpy(hackvist.buffer, argv[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19">  printf(<span class="st">&quot;abracadabra function address: %p</span><span class="sc">\n</span><span class="st">&quot;</span>,abracadabra);</a>
<a class="sourceLine" id="cb1-20" title="20">  printf(<span class="st">&quot;hackvist.point after strcpy: %p</span><span class="sc">\n</span><span class="st">&quot;</span>, hackvist.point);</a>
<a class="sourceLine" id="cb1-21" title="21">  <span class="cf">if</span> (hackvist.point) {</a>
<a class="sourceLine" id="cb1-22" title="22">    fflush(stdout);</a>
<a class="sourceLine" id="cb1-23" title="23">    hackvist.point();</a>
<a class="sourceLine" id="cb1-24" title="24">  } <span class="cf">else</span> {</a>
<a class="sourceLine" id="cb1-25" title="25">    printf(<span class="st">&quot;Try Again</span><span class="sc">\n</span><span class="st">&quot;</span>);</a>
<a class="sourceLine" id="cb1-26" title="26">  }</a>
<a class="sourceLine" id="cb1-27" title="27"></a>
<a class="sourceLine" id="cb1-28" title="28">  exit(<span class="dv">0</span>);</a>
<a class="sourceLine" id="cb1-29" title="29">}</a></code></pre></div>
<h2 id="the-code-in-rust">3. The code in Rust</h2>
<p>My goal was to translate this code above into Rust. This is the function we’ll try to call:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">fn</span> abracadabra() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="pp">println!</span>(<span class="st">&quot;Abracadabra! Function called!&quot;</span>);</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="op">}</span></a></code></pre></div>
<p>And this is the struct with a buffer, which we’ll try to overflow:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb3-1" title="1"><span class="at">#[</span>repr<span class="at">(</span>C<span class="at">)]</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">struct</span> Hackvist <span class="op">{</span></a>
<a class="sourceLine" id="cb3-3" title="3">    buffer: <span class="op">[</span><span class="dt">u8</span>; <span class="dv">16</span><span class="op">]</span>,</a>
<a class="sourceLine" id="cb3-4" title="4">    point: *<span class="kw">const</span> <span class="kw">fn</span>(),</a>
<a class="sourceLine" id="cb3-5" title="5"><span class="op">}</span></a></code></pre></div>
<p>We’ll also need some unsafe function, to copy bytes without checking the size of the destination buffer. This can be done with <code>std::ptr::copy()</code>.</p>
<p>At the end, to make our life easier, we’ll add printing of <code>abracadabra()</code> function address, as well as, the content of <code>hackvist.point</code>, so we can find out what should we provide as an input to call <code>abracadabra()</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb4-1" title="1"><span class="pp">println!</span>(<span class="st">&quot;abracadabra function address: x{:0x}&quot;</span>, abracadabra <span class="kw">as</span> <span class="dt">usize</span>);</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="pp">println!</span>(<span class="st">&quot;hackvist.point after strcpy: x{:0x}&quot;</span>, hackvist.point <span class="kw">as</span> <span class="dt">usize</span>);</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="pp">println!</span>(<span class="st">&quot;hackvist.point after strcpy (in chars): {:?}&quot;</span>, (hackvist.point <span class="kw">as</span> <span class="dt">usize</span> <span class="kw">as</span> <span class="dt">u64</span>).to_le_bytes().into_iter().map(|b| <span class="dt">char</span>::from(b)).<span class="pp">collect::</span>&lt;<span class="dt">String</span>&gt;());</a></code></pre></div>
<p>Taken all of this together, this is the source code for this buffer overflow exercise:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">use</span> <span class="pp">std::</span>env;</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">use</span> <span class="pp">std::ffi::</span>OsString;</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">use</span> <span class="pp">std::os::unix::ffi::</span>OsStrExt;</a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">fn</span> abracadabra() <span class="op">{</span></a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="pp">println!</span>(<span class="st">&quot;Abracadabra! Function called!&quot;</span>);</a>
<a class="sourceLine" id="cb5-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb5-8" title="8"></a>
<a class="sourceLine" id="cb5-9" title="9"><span class="at">#[</span>repr<span class="at">(</span>C<span class="at">)]</span></a>
<a class="sourceLine" id="cb5-10" title="10"><span class="kw">struct</span> Hackvist <span class="op">{</span></a>
<a class="sourceLine" id="cb5-11" title="11">    buffer: <span class="op">[</span><span class="dt">u8</span>; <span class="dv">16</span><span class="op">]</span>,</a>
<a class="sourceLine" id="cb5-12" title="12">    point: *<span class="kw">const</span> <span class="kw">fn</span>(),</a>
<a class="sourceLine" id="cb5-13" title="13"><span class="op">}</span></a>
<a class="sourceLine" id="cb5-14" title="14"></a>
<a class="sourceLine" id="cb5-15" title="15"><span class="kw">fn</span> main() <span class="op">{</span></a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="kw">let</span> <span class="kw">mut</span> args: <span class="dt">Vec</span>&lt;OsString&gt; = <span class="pp">env::</span>args_os().into_iter().collect();</a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="kw">let</span> first_arg: OsString = args.remove(<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb5-18" title="18">    <span class="kw">let</span> input_bytes: &amp;<span class="op">[</span><span class="dt">u8</span><span class="op">]</span> = first_arg.as_bytes();</a>
<a class="sourceLine" id="cb5-19" title="19">    <span class="kw">let</span> <span class="kw">mut</span> hackvist = Hackvist <span class="op">{</span></a>
<a class="sourceLine" id="cb5-20" title="20">        buffer: <span class="op">[</span><span class="dv">0</span>; <span class="dv">16</span><span class="op">]</span>,</a>
<a class="sourceLine" id="cb5-21" title="21">        point: <span class="dv">0</span> <span class="kw">as</span> *<span class="kw">const</span> <span class="kw">fn</span>() -&gt; (),</a>
<a class="sourceLine" id="cb5-22" title="22">    <span class="op">}</span>;</a>
<a class="sourceLine" id="cb5-23" title="23"></a>
<a class="sourceLine" id="cb5-24" title="24">    <span class="kw">unsafe</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-25" title="25">        <span class="pp">std::ptr::</span>copy(input_bytes.as_ptr(), hackvist.buffer.as_mut_ptr(), input_bytes.len())</a>
<a class="sourceLine" id="cb5-26" title="26">    <span class="op">}</span></a>
<a class="sourceLine" id="cb5-27" title="27"></a>
<a class="sourceLine" id="cb5-28" title="28">    <span class="pp">println!</span>(<span class="st">&quot;abracadabra function address: x{:0x}&quot;</span>, abracadabra <span class="kw">as</span> <span class="dt">usize</span>);</a>
<a class="sourceLine" id="cb5-29" title="29">    <span class="pp">println!</span>(<span class="st">&quot;hackvist.point after strcpy: x{:0x}&quot;</span>, hackvist.point <span class="kw">as</span> <span class="dt">usize</span>);</a>
<a class="sourceLine" id="cb5-30" title="30">    <span class="pp">println!</span>(<span class="st">&quot;hackvist.point after strcpy (in chars): {:?}&quot;</span>, (hackvist.point <span class="kw">as</span> <span class="dt">usize</span> <span class="kw">as</span> <span class="dt">u64</span>).to_le_bytes().into_iter().map(|b| <span class="dt">char</span>::from(b)).<span class="pp">collect::</span>&lt;<span class="dt">String</span>&gt;());</a>
<a class="sourceLine" id="cb5-31" title="31"></a>
<a class="sourceLine" id="cb5-32" title="32">    <span class="kw">if</span> hackvist.point <span class="kw">as</span> <span class="dt">usize</span> == <span class="dv">0</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-33" title="33">        <span class="pp">println!</span>(<span class="st">&quot;Try again&quot;</span>);</a>
<a class="sourceLine" id="cb5-34" title="34">    <span class="op">}</span> <span class="kw">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-35" title="35">        <span class="kw">let</span> code: <span class="kw">fn</span>() = <span class="kw">unsafe</span> <span class="op">{</span> <span class="pp">std::mem::</span>transmute(hackvist.point) <span class="op">}</span>;</a>
<a class="sourceLine" id="cb5-36" title="36">        code();</a>
<a class="sourceLine" id="cb5-37" title="37">    <span class="op">}</span></a>
<a class="sourceLine" id="cb5-38" title="38"><span class="op">}</span></a></code></pre></div>
<h2 id="running-it">4. Running it!</h2>
<p>Now, let’s try to build it:</p>
<pre><code>$ cargo build</code></pre>
<p>And run (the values can differ on your computer):</p>
<pre><code>$ ./target/debug/buffer-overflow &quot;AAAABBBB&quot;
abracadabra function address: x5597c4265bb0
hackvist.point after strcpy: x0
hackvist.point after strcpy (in chars): &quot;\u{0}\u{0}\u{0}\u{0}\u{0}\u{0}\u{0}\u{0}&quot;
Try again</code></pre>
<p>This time the input string was too short <code>AAAABBBB</code> has only 8 bytes, so it wasn’t enough to overflow our 16 byte buffer and write into <code>hackvist.point</code> function pointer. Let’s try with longer input:</p>
<pre><code>$ ./target/debug/buffer-overflow &quot;AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH&quot;
abracadabra function address: x55e1e06cbbb0
hackvist.point after strcpy: x4646464645454545
hackvist.point after strcpy (in chars): &quot;EEEEFFFF&quot;
Segmentation fault (core dumped)</code></pre>
<p>As we can see, we managed to overflow the buffer and write into the function pointer. It wasn’t correctly set, so there was a segmentation fault.</p>
<p>Right now we’ll want to change letters <code>EEEEFFFF</code> in the input string into <code>abracadabra()</code> function address. Let’s try:</p>
<pre><code>$ ./target/debug/buffer-overflow \
&gt; $(python -c 'print &quot;AAAABBBBCCCCDDDD\xb0\xbb\x6c\xe0\xe1\x55&quot;')
abracadabra function address: x55d7609eabb0
hackvist.point after strcpy: x55e1e06cbbb0
hackvist.point after strcpy (in chars): &quot;°»làáU\u{0}\u{0}&quot;
Segmentation fault (core dumped)</code></pre>
<p>It didn’t work, even though the <code>hackvist.point</code> was “correctly” overwritten with <code>x55e1e06cbbb0</code>, which is exactly the <code>abracadabra()</code> function address from our previous run: <code>x55e1e06cbbb0</code>.</p>
<p>The reason for this is that on my machine, <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">address space layout randomization</a> is used to make buffer overflow attacks harder. This can be turned off by running the binary with:</p>
<pre><code>$ setarch x86_64 -R ./target/debug/buffer-overflow \
&gt; $(python -c 'print &quot;AAAABBBBCCCCDDDD\xb0\xbb\x6c\xe0\xe1\x55&quot;')
abracadabra function address: x55555555cbb0
hackvist.point after strcpy: x55e1e06cbbb0
hackvist.point after strcpy (in chars): &quot;°»làáU\u{0}\u{0}&quot;
Segmentation fault (core dumped)</code></pre>
<p>This time the address has changed once again, but from now on, the <code>abracadabra()</code> function address shouldn’t change, so we can use <code>x55555555cbb0</code> address in our input:</p>
<pre><code>$ setarch x86_64 -R ./target/debug/buffer-overflow \
&gt; $(python -c 'print &quot;AAAABBBBCCCCDDDD\xb0\xcb\x55\x55\x55\x55&quot;')
abracadabra function address: x55555555cbb0
hackvist.point after strcpy: x55555555cbb0
hackvist.point after strcpy (in chars): &quot;°ËUUUU\u{0}\u{0}&quot;
Abracadabra! Function called!</code></pre>
<p>Success! Buffer overflow has overwritten the <code>hackvist.point</code> pointer with a valid function address and we have changed the program behaviour with our sneaky input :)</p>
    </section>
</article>

            </div>
        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
    </body>
</html>
